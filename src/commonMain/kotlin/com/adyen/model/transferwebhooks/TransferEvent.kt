/**
 * Transfer webhooks
 *
 * Adyen sends webhooks to inform your system about incoming and outgoing transfers in your platform.  You can use these webhooks to build your implementation. For example, you can use this information to update balances in your own dashboards or to keep track of incoming funds.
 *
 * The version of the OpenAPI document: 4
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.adyen.model.transferwebhooks

import com.adyen.model.transferwebhooks.Amount
import com.adyen.model.transferwebhooks.AmountAdjustment
import com.adyen.model.transferwebhooks.BalanceMutation
import com.adyen.model.transferwebhooks.Modification

import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

/**
 * 
 *
 * @param amount 
 * @param amountAdjustments The amount adjustments in this transfer.
 * @param bookingDate The date when the transfer request was sent.
 * @param estimatedArrivalTime The estimated time the beneficiary should have access to the funds.
 * @param id The unique identifier of the transfer event.
 * @param modification 
 * @param mutations The list of the balance mutation per event.
 * @param originalAmount 
 * @param reason The reason for the transfer status.
 * @param schemeTraceID SchemeTraceID retrieved from scheme.
 * @param schemeUniqueTransactionID SchemeUniqueTransactionID retrieved from scheme.
 * @param status The status of the transfer event.
 * @param transactionId The id of the transaction that is related to this accounting event. Only sent for events of type **accounting** where the balance changes.
 * @param type The type of the transfer event. Possible values: **accounting**, **tracking**.
 * @param updateDate The date when the tracking status was updated.
 * @param valueDate A future date, when the funds are expected to be deducted from or credited to the balance account.
 */
@Serializable
data class TransferEvent (

    @SerialName(value = "amount") val amount: Amount? = null,

    /* The amount adjustments in this transfer. */
    @SerialName(value = "amountAdjustments") val amountAdjustments: kotlin.collections.List<AmountAdjustment>? = null,

    /* The date when the transfer request was sent. */
    @SerialName(value = "bookingDate") val bookingDate: kotlin.String? = null,

    /* The estimated time the beneficiary should have access to the funds. */
    @SerialName(value = "estimatedArrivalTime") val estimatedArrivalTime: kotlin.String? = null,

    /* The unique identifier of the transfer event. */
    @SerialName(value = "id") val id: kotlin.String? = null,

    @SerialName(value = "modification") val modification: Modification? = null,

    /* The list of the balance mutation per event. */
    @SerialName(value = "mutations") val mutations: kotlin.collections.List<BalanceMutation>? = null,

    @SerialName(value = "originalAmount") val originalAmount: Amount? = null,

    /* The reason for the transfer status. */
    @SerialName(value = "reason") val reason: TransferEvent.Reason? = null,

    /* SchemeTraceID retrieved from scheme. */
    @SerialName(value = "schemeTraceID") val schemeTraceID: kotlin.String? = null,

    /* SchemeUniqueTransactionID retrieved from scheme. */
    @SerialName(value = "schemeUniqueTransactionID") val schemeUniqueTransactionID: kotlin.String? = null,

    /* The status of the transfer event. */
    @SerialName(value = "status") val status: TransferEvent.Status? = null,

    /* The id of the transaction that is related to this accounting event. Only sent for events of type **accounting** where the balance changes. */
    @SerialName(value = "transactionId") val transactionId: kotlin.String? = null,

    /* The type of the transfer event. Possible values: **accounting**, **tracking**. */
    @SerialName(value = "type") val type: TransferEvent.Type? = null,

    /* The date when the tracking status was updated. */
    @SerialName(value = "updateDate") val updateDate: kotlin.String? = null,

    /* A future date, when the funds are expected to be deducted from or credited to the balance account. */
    @SerialName(value = "valueDate") val valueDate: kotlin.String? = null

) {

    /**
     * The reason for the transfer status.
     *
     * Values: AmountLimitExceeded,Approved,BalanceAccountTemporarilyBlockedByTransactionRule,CounterpartyAccountBlocked,CounterpartyAccountClosed,CounterpartyAccountNotFound,CounterpartyAddressRequired,CounterpartyBankTimedOut,CounterpartyBankUnavailable,DeclinedByTransactionRule,Error,NotEnoughBalance,RefusedByCounterpartyBank,RouteNotFound,ScaFailed,Unknown
     */
    @Serializable
    enum class Reason(val value: kotlin.String) {
        @SerialName(value = "amountLimitExceeded") AmountLimitExceeded("amountLimitExceeded"),
        @SerialName(value = "approved") Approved("approved"),
        @SerialName(value = "balanceAccountTemporarilyBlockedByTransactionRule") BalanceAccountTemporarilyBlockedByTransactionRule("balanceAccountTemporarilyBlockedByTransactionRule"),
        @SerialName(value = "counterpartyAccountBlocked") CounterpartyAccountBlocked("counterpartyAccountBlocked"),
        @SerialName(value = "counterpartyAccountClosed") CounterpartyAccountClosed("counterpartyAccountClosed"),
        @SerialName(value = "counterpartyAccountNotFound") CounterpartyAccountNotFound("counterpartyAccountNotFound"),
        @SerialName(value = "counterpartyAddressRequired") CounterpartyAddressRequired("counterpartyAddressRequired"),
        @SerialName(value = "counterpartyBankTimedOut") CounterpartyBankTimedOut("counterpartyBankTimedOut"),
        @SerialName(value = "counterpartyBankUnavailable") CounterpartyBankUnavailable("counterpartyBankUnavailable"),
        @SerialName(value = "declinedByTransactionRule") DeclinedByTransactionRule("declinedByTransactionRule"),
        @SerialName(value = "error") Error("error"),
        @SerialName(value = "notEnoughBalance") NotEnoughBalance("notEnoughBalance"),
        @SerialName(value = "refusedByCounterpartyBank") RefusedByCounterpartyBank("refusedByCounterpartyBank"),
        @SerialName(value = "routeNotFound") RouteNotFound("routeNotFound"),
        @SerialName(value = "scaFailed") ScaFailed("scaFailed"),
        @SerialName(value = "unknown") Unknown("unknown");
    }
    /**
     * The status of the transfer event.
     *
     * Values: ApprovalPending,AtmWithdrawal,AtmWithdrawalReversalPending,AtmWithdrawalReversed,AuthAdjustmentAuthorised,AuthAdjustmentError,AuthAdjustmentRefused,Authorised,BankTransfer,BankTransferPending,Booked,BookingPending,Cancelled,CapturePending,CaptureReversalPending,CaptureReversed,Captured,CapturedExternally,Chargeback,ChargebackExternally,ChargebackPending,ChargebackReversalPending,ChargebackReversed,Credited,DepositCorrection,DepositCorrectionPending,Dispute,DisputeClosed,DisputeExpired,DisputeNeedsReview,Error,Expired,Failed,Fee,FeePending,InternalTransfer,InternalTransferPending,InvoiceDeduction,InvoiceDeductionPending,ManualCorrectionPending,ManuallyCorrected,MatchedStatement,MatchedStatementPending,MerchantPayin,MerchantPayinPending,MerchantPayinReversed,MerchantPayinReversedPending,MiscCost,MiscCostPending,PaymentCost,PaymentCostPending,Received,RefundPending,RefundReversalPending,RefundReversed,Refunded,RefundedExternally,Refused,ReserveAdjustment,ReserveAdjustmentPending,Returned,SecondChargeback,SecondChargebackPending,Undefined
     */
    @Serializable
    enum class Status(val value: kotlin.String) {
        @SerialName(value = "approvalPending") ApprovalPending("approvalPending"),
        @SerialName(value = "atmWithdrawal") AtmWithdrawal("atmWithdrawal"),
        @SerialName(value = "atmWithdrawalReversalPending") AtmWithdrawalReversalPending("atmWithdrawalReversalPending"),
        @SerialName(value = "atmWithdrawalReversed") AtmWithdrawalReversed("atmWithdrawalReversed"),
        @SerialName(value = "authAdjustmentAuthorised") AuthAdjustmentAuthorised("authAdjustmentAuthorised"),
        @SerialName(value = "authAdjustmentError") AuthAdjustmentError("authAdjustmentError"),
        @SerialName(value = "authAdjustmentRefused") AuthAdjustmentRefused("authAdjustmentRefused"),
        @SerialName(value = "authorised") Authorised("authorised"),
        @SerialName(value = "bankTransfer") BankTransfer("bankTransfer"),
        @SerialName(value = "bankTransferPending") BankTransferPending("bankTransferPending"),
        @SerialName(value = "booked") Booked("booked"),
        @SerialName(value = "bookingPending") BookingPending("bookingPending"),
        @SerialName(value = "cancelled") Cancelled("cancelled"),
        @SerialName(value = "capturePending") CapturePending("capturePending"),
        @SerialName(value = "captureReversalPending") CaptureReversalPending("captureReversalPending"),
        @SerialName(value = "captureReversed") CaptureReversed("captureReversed"),
        @SerialName(value = "captured") Captured("captured"),
        @SerialName(value = "capturedExternally") CapturedExternally("capturedExternally"),
        @SerialName(value = "chargeback") Chargeback("chargeback"),
        @SerialName(value = "chargebackExternally") ChargebackExternally("chargebackExternally"),
        @SerialName(value = "chargebackPending") ChargebackPending("chargebackPending"),
        @SerialName(value = "chargebackReversalPending") ChargebackReversalPending("chargebackReversalPending"),
        @SerialName(value = "chargebackReversed") ChargebackReversed("chargebackReversed"),
        @SerialName(value = "credited") Credited("credited"),
        @SerialName(value = "depositCorrection") DepositCorrection("depositCorrection"),
        @SerialName(value = "depositCorrectionPending") DepositCorrectionPending("depositCorrectionPending"),
        @SerialName(value = "dispute") Dispute("dispute"),
        @SerialName(value = "disputeClosed") DisputeClosed("disputeClosed"),
        @SerialName(value = "disputeExpired") DisputeExpired("disputeExpired"),
        @SerialName(value = "disputeNeedsReview") DisputeNeedsReview("disputeNeedsReview"),
        @SerialName(value = "error") Error("error"),
        @SerialName(value = "expired") Expired("expired"),
        @SerialName(value = "failed") Failed("failed"),
        @SerialName(value = "fee") Fee("fee"),
        @SerialName(value = "feePending") FeePending("feePending"),
        @SerialName(value = "internalTransfer") InternalTransfer("internalTransfer"),
        @SerialName(value = "internalTransferPending") InternalTransferPending("internalTransferPending"),
        @SerialName(value = "invoiceDeduction") InvoiceDeduction("invoiceDeduction"),
        @SerialName(value = "invoiceDeductionPending") InvoiceDeductionPending("invoiceDeductionPending"),
        @SerialName(value = "manualCorrectionPending") ManualCorrectionPending("manualCorrectionPending"),
        @SerialName(value = "manuallyCorrected") ManuallyCorrected("manuallyCorrected"),
        @SerialName(value = "matchedStatement") MatchedStatement("matchedStatement"),
        @SerialName(value = "matchedStatementPending") MatchedStatementPending("matchedStatementPending"),
        @SerialName(value = "merchantPayin") MerchantPayin("merchantPayin"),
        @SerialName(value = "merchantPayinPending") MerchantPayinPending("merchantPayinPending"),
        @SerialName(value = "merchantPayinReversed") MerchantPayinReversed("merchantPayinReversed"),
        @SerialName(value = "merchantPayinReversedPending") MerchantPayinReversedPending("merchantPayinReversedPending"),
        @SerialName(value = "miscCost") MiscCost("miscCost"),
        @SerialName(value = "miscCostPending") MiscCostPending("miscCostPending"),
        @SerialName(value = "paymentCost") PaymentCost("paymentCost"),
        @SerialName(value = "paymentCostPending") PaymentCostPending("paymentCostPending"),
        @SerialName(value = "received") Received("received"),
        @SerialName(value = "refundPending") RefundPending("refundPending"),
        @SerialName(value = "refundReversalPending") RefundReversalPending("refundReversalPending"),
        @SerialName(value = "refundReversed") RefundReversed("refundReversed"),
        @SerialName(value = "refunded") Refunded("refunded"),
        @SerialName(value = "refundedExternally") RefundedExternally("refundedExternally"),
        @SerialName(value = "refused") Refused("refused"),
        @SerialName(value = "reserveAdjustment") ReserveAdjustment("reserveAdjustment"),
        @SerialName(value = "reserveAdjustmentPending") ReserveAdjustmentPending("reserveAdjustmentPending"),
        @SerialName(value = "returned") Returned("returned"),
        @SerialName(value = "secondChargeback") SecondChargeback("secondChargeback"),
        @SerialName(value = "secondChargebackPending") SecondChargebackPending("secondChargebackPending"),
        @SerialName(value = "undefined") Undefined("undefined");
    }
    /**
     * The type of the transfer event. Possible values: **accounting**, **tracking**.
     *
     * Values: Accounting,Tracking
     */
    @Serializable
    enum class Type(val value: kotlin.String) {
        @SerialName(value = "accounting") Accounting("accounting"),
        @SerialName(value = "tracking") Tracking("tracking");
    }
}

